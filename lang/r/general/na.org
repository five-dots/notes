#+STARTUP: folded indent
#+PROPERTY: header-args:R :results output :colnames yes :exports both :session *R:na*
#+OPTIONS: author:nil 
#+HUGO_BASE_DIR: ~/Dropbox/repos/github/five-dots/blog
#+HUGO_SECTION: post

* DONE R のモダンな NA 処理まとめ
CLOSED: [2019-11-03 Sun 16:21]
:PROPERTIES:
:EXPORT_FILE_NAME: r-na-manip
:EXPORT_HUGO_SECTION*: 2019/11/
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :toc true
:END:

データの欠損値を表す ~NA~ 。その ~NA~ をモダンなパッケージを用いて処理する方法についてまとめる。特に ~vector~ と ~data.frame~ に対して ~NA~ の削除や置換方法を中心に記載していきたい。

※ここで「モダン」と言っているのは、特に明確な定義があるわけではなく、最近開発されたパッケージという程度の意味である。

** 方針

この記事では ~{dplyr}~ や ~{tidyr}~ などのパッケージを積極的に使って ~NA~ 処理をする方法を紹介する方針だ。もちろん ~{base}~ の機能でも基本的な ~NA~ 処理は可能だ。

例えば ~vector~ から ~NA~ を削除する場合には、
#+begin_src R :exports both
x <- c(1, 2, 3, NA, 5)
x[!is.na(x)]
#+end_src

#+RESULTS:
: 
: [1] 1 2 3 5

~NA~ を特定の値をに設定したい場合には、
#+begin_src R
x[is.na(x)] <- 0 # NA を 0 で置換
x
#+end_src

#+RESULTS:
: 
: [1] 1 2 3 0 5

と書くのが一般的だろう。添字に ~logical vector~ やインデックスを渡すこのやり方は、いかにも R っぽいコードであるし、汎用的でもある。

ただ、個人的にはこの記述法はできるだけ避けるべきと考えている。プログラミングは *「どのようにやるか (How)」ではなく、「何をやるか (What)」* という視点で書くべきだからだ。このくらいシンプルな例であれば問題ないかもしれないが、インデックスに複雑な計算が入っていたり ~for~ がネストされていて ~i, j, k...~ などと登場してくるととても読む気がなくなってしまうし、まさに How にフォーカスした書き方と言えるだろう。

後者の例であれば ~{tidyr}~ を使って、こう書いた方が「何をしたいか (What)」が明確でよりわかりやすい。
#+begin_src R
tidyr::replace_na(x, 0) 
#+end_src

#+RESULTS:
: [1] 1 2 3 0 5
 
いつでも使いたいパッケージを使うことができる、という環境にない場合もあるだろうし、何だかんだで ~{base}~ での書き方も押さえておく必要がある。どちらも学ぶ必要があって、大変というのは 「R あるある」かもしれないが、将来コードを見え返す自分のためにも、少しでもわかりやすいコードを心がけるのは有益だと思う。

** 紹介する関数まとめ

代表的な ~NA~ 処理毎に ~{base}~ の機能のみを使った一般的な書き方と、今回紹介する関数を ~vector~, ~data.frame~ 毎に一覧にまとめるとこのようになる。「 ~NA~ *を* 置換」は ~NA~ を ~0~ に置換する場合、「 ~NA~ *に* 置換」は ~1~ を ~NA~ に置換すると想定した場合の例である。

|           | ~{base}~ パッケージ    | ~vector~                           | ~data.frame~                       |
|-----------+----------------------+----------------------------------+----------------------------------|
| NA を削除 | ~x[!is.na(x]~          | ~na.omit(x)~                       | ~drop_na(df everything())~         |
| NA の有無 | ~stopifnot(!anyNA(x))~ | ~assert_that(noNA(x))~             | ~assert(df, not_na, everything())~ |
| NA を置換 | ~x[is.na(x)] <- 0~     | ~replace_na(x, 0)~, ~coalesce(x, 0)~ | ~replace_na(df, list(x = 0))~      |
| NA に置換 | ~x[x == 1] <- NA~      | ~na_if(x, 1)~                      | ~mutate(df, na_if(x, 1))~          |

また ~data.frame~ 向けの特殊な例として ~tidyr::fill()~ と ~recipes::step_meanimpute()~ などの ~step_*impute()~ の関数も一部紹介する。

** ライブラリの読み込み

まずは、パッケージの読み込みから。この記事内で扱うパッケージは、以下の通り。
#+begin_src R :results silent
library(dplyr)
library(tidyr)
library(recipes)
library(assertr)
library(assertthat)
#+end_src

** NA には型がある

具体的な内容に入る前に ~NA~ の型について確認しておきたい。自分自身、よく理解せずに過去にハマった経験があるからだ。

~NA~ には型がある。単に ~NA~ とした場合には ~logical~ 型である。例えば ~character~ 型の ~NA~ が欲しい場合には ~NA_character_~ とする必要がある。この辺りのことは ~?NA~ を見るか、日本語では [[https://qiita.com/fujit33/items/5950889b983f93250998][こちら]] の記事が詳しい。

#+begin_src R
purrr::map_lgl(c(NA, NA_integer_, NA_real_, NA_character_, NA_complex_), is.na)
#+end_src

#+RESULTS:
: [1] TRUE TRUE TRUE TRUE TRUE

#+begin_src R
is.logical(NA)
is.numeric(NA_real_)
is.integer(NA_integer_)
is.character(NA_character_)
is.complex(NA_complex_)
#+end_src

#+RESULTS:
: [1] TRUE
: 
: [1] TRUE
: 
: [1] TRUE
: 
: [1] TRUE
: 
: [1] TRUE

この「 ~NA~ の型」が問題になる例として、 ~dplyr::if_else()~ や ~dplyr::case_when()~ など *関数の返り値の型が同じかどうかを厳密にチェックするタイプの関数* を利用する場合がある。

例えば、この例は ~base::ifelse()~ では意図した通りの結果になるが ~dplyr::if_else()~ ではエラーになる。

- ~base::ifelse()~
#+begin_src R
x <- c(3, 2, 1, 0, -1, -2, -3)
ifelse(x > 0, "positive", NA)
#+end_src

#+RESULTS:
: 
: [1] "positive" "positive" "positive" NA         NA         NA         NA

- ~dplyr::if_else()~
#+begin_src R
dplyr::if_else(x > 0, "positive", NA)
#+end_src

#+RESULTS:
: Error: `false` must be a character vector, not a logical vector
: Call `rlang::last_error()` to see a backtrace

これは ~dplyr::if_else()~ が ~TRUE/FALSE~ の評価結果として、同じ型であることを求めるからだ。この場合には、 ~NA_character_~ を使って明示的に ~character~ 型の欠損値であることを示す必要がある。
#+begin_src R
dplyr::if_else(x > 0, "positive", NA_character_)
#+end_src

#+RESULTS:
: [1] "positive" "positive" "positive" NA         NA         NA         NA

自らがコードの中で ~NA~ を設定する場合には、必ず型を明示したほうがより安全になるだろう。(そのお陰で ~base::ifelse()~ よりも ~dplyr::if_else()~ のほうが若干高速らしい)

** 利用するデータ

~vector~, ~data.frame~ ともにできるだけシンプルなデータを用意する。

- ~vector~
#+begin_src R
x <- c(1, 2, 3, NA, 5)
x
#+end_src

#+RESULTS:
: 
: [1]  1  2  3 NA  5

- ~data.frame~
#+begin_src R
df <- data.frame(
  x = c(1, 2, 3),
  y = c(1, NA, 3),
  z = c(1, NA, NA)
)
df
#+end_src

#+RESULTS:
: 
:   x  y  z
: 1 1  1  1
: 2 2 NA NA
: 3 3  3 NA

※この記事は、emacs の org-mode を使って執筆しているが、org-mode では ~NA~ が ~nil~ と記載されてしまうので、適宜読み替えていただきたい。

** NA を削除する
*** vector

- ~stata::na.omit(object, ...)~ を使う
- モダンなパッケージと言っておきながら ~{stats}~ からの関数だが、十分にシンプルかつ明確
- 取り除かれたインデックスを ~attribute~ として保持してくれる
#+begin_src R
x <- c(1, 2, 3, NA, 5)
na.omit(x)
#+end_src

#+RESULTS:
: 
: [1] 1 2 3 5
: attr(,"na.action")
: [1] 4
: attr(,"class")
: [1] "omit"

*** data.frame

- ~tidyr::drop_na(data, ...)~ を使う
- 特定の列の ~NA~ を省いた ~data.frame~ を返してくれる
- 列選択には ~dplyr::select()~ 同様の方法が利用できる
#+begin_src R :results value
df %>%
  drop_na(y) # y列の NA を含む行を削除
#+end_src

#+RESULTS:
| x | y | z   |
|---+---+-----|
| 1 | 1 | 1   |
| 3 | 3 | nil |

- 全ての列から ~NA~ を含む行を削除したい場合は ~tidyselect::everything()~ を使う
- ~filter(df, complete.cases(df))~ と同じだが、個人的にはより意図が明確になると思う
#+begin_src R :results value
df %>%
  drop_na(everything())
#+end_src

#+RESULTS:
| x | y | z |
|---+---+---|
| 1 | 1 | 1 |

** NA が含まれていないか確認する (アサーション)

関数の入力値のチェックや、一連のデータ処理の間でアサーションを行いたい場合の例。

*** vector

- ~assertthat::noNA()~ を使う
#+begin_src R
x <- c(1, 2, NA, 4)
assert_that(noNA(x))
#+end_src

#+RESULTS:
: 
: Error: x contains 1 missing values

- ~{base}~ のみだと以下のように書くことができるが ~{assertthat}~ の方がエラーが明確でわかりやすい。
#+begin_src R
stopifnot(!anyNA(x))
#+end_src

#+RESULTS:
: Error: !anyNA(x) is not TRUE

*** data.frame

- ~assertr::assert()~ と ~assertr::not_na()~ を組み合わせる
- [[https://github.com/ropensci/assertr][ ~{assertr}~ ]] は ~data.frame~ をパイプ内でアサーションするためのパッケージ
- エラーの場合に、違反箇所を明示してくれる
#+begin_src R
df %>%
 # dplyr等のなんらかの処理 %>%
 assert(not_na, y) # 結果が意図通りかを確認するためのアサーションをパイプで挟む
#+end_src

#+RESULTS:
: 
: Column 'y' violates assertion 'not_na' 1 time
:     verb redux_fn predicate column index value
: 1 assert       NA    not_na      y     2    NA
: 
: Error: assertr stopped execution

- 列選択には ~{tidyselect}~ の関数が利用できるので、全ての列に対して NA チェックをしたい場合は ~everything()~ とすれば良い
#+begin_src R
df %>% assert(not_na, everything())
#+end_src

#+RESULTS:
#+begin_example
Column 'y' violates assertion 'not_na' 1 time
    verb redux_fn predicate column index value
1 assert       NA    not_na      y     2    NA

Column 'z' violates assertion 'not_na' 2 times
    verb redux_fn predicate column index value
1 assert       NA    not_na      z     2    NA
2 assert       NA    not_na      z     3    NA

Error: assertr stopped execution
#+end_example

** NA を置換する
*** vector

- ~tidyr::replace_na()~ を使う
#+begin_src R
replace_na(x, 0)
#+end_src

#+RESULTS:
: [1] 1 2 0 4

- 置換したい値が 1 つ出ない場合、 ~dplyr::coalesce()~ を使う
- 複数のベクトルから、最初の ~NA~ でない値を返してくれる
- 複数のベクトルの指定した順に ~NA~ でない値で合体してくれるイメージ
- 全ての引数は、長さ 1 もしくは、第 1 引数と同じ長さである必要がある
#+begin_src R
y <- c(1, 2, 3, 4)
coalesce(x, y)
#+end_src

#+RESULTS:
: 
: [1] 1 2 3 4

*** data.frame

- ~data.frame~ の場合も ~replace_na()~ を使う
- ただし、置換後の値を列ごとに ~list~ で指定する
#+begin_src R :results value
replace_na(df, replace = list(y = 0, z = 2))
#+end_src

#+RESULTS:
| x | y | z |
|---+---+---|
| 1 | 1 | 1 |
| 2 | 0 | 2 |
| 3 | 3 | 2 |

- 直前の NA でない値で置換したい場合 ~tidyr::fill()~ を使う
- 時系列データの NA 置換でよく利用する
- ~.direction = "down"/"up"~ で下方向に置換するか、上方向に置換するかを選ぶことができる
#+begin_src R :results value
fill(df, y, .direction = "down")
#+end_src

#+RESULTS:
| x | y | z   |
|---+---+-----|
| 1 | 1 | 1   |
| 2 | 1 | nil |
| 3 | 3 | nil |

- 特定の値ではなく、より柔軟に ~NA~ を置換したい場合は [[https://github.com/tidymodels/recipes][ ~{recipes}~ ]]パッケージの ~step_*impute()~ 関数群を使う
- 例えば、平均値で置換したい場合は ~step_meanimpute()~
#+begin_src R :results value
df %>%
  recipe() %>%
  step_meanimpute(y, z) %>%
  prep() %>%
  juice()
#+end_src

#+RESULTS:
| x | y | z |
|---+---+---|
| 1 | 1 | 1 |
| 2 | 2 | 1 |
| 3 | 3 | 1 |

- ~step_*impute()~ 系は現状 7 つの関数が用意されている
- 機能は名前からなんとなく想像はできると思うが、詳細はマニュアル参照
#+begin_src R
pacman::p_funs(recipes) %>%
  stringr::str_subset("^step_.*impute$")
#+end_src

#+RESULTS:
: 
: [1] "step_bagimpute"    "step_knnimpute"    "step_lowerimpute" 
: [4] "step_meanimpute"   "step_medianimpute" "step_modeimpute"  
: [7] "step_rollimpute"

** NA に置換する
*** vector

- ~dplyr::na_if(x, y)~ を使う
- 特定の値を ~NA~ に置き換える
- 不正な値を ~NA~ にして、除外する際に使う
- ~x~: 対象となるベクトル
- ~y~: ~NA~ に置換するベクトル
#+begin_src R :results output :exports both
na_if(x, 1)
#+end_src

#+RESULTS:
: [1] NA  2 NA  4

*** data.frame

- data.frame の場合も 
#+begin_src R :results value
df %>%
  mutate(b = na_if(y, 1))
#+end_src

#+RESULTS:
| x |   y | z   | b   |
|---+-----+-----+-----|
| 1 |   1 | 1   | nil |
| 2 | nil | nil | nil |
| 3 |   3 | nil | 3   |

#+begin_src R :results value
df %>%
  mutate_at(vars(everything()), na_if, y=1)
#+end_src

#+RESULTS:
|   x | y   | z   |
|-----+-----+-----|
| nil | nil | nil |
|   2 | nil | nil |
|   3 | 3   | nil |
